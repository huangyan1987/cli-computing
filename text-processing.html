<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Text Processing - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux command line and Scripting guide for beginner to intermediate users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>1.</strong> Introduction</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=working-with-files-and-directories.html><strong aria-hidden=true>4.</strong> Working with Files and Directories</a><li class="chapter-item expanded"><a href=text-processing.html class=active><strong aria-hidden=true>5.</strong> Text Processing</a><li class="chapter-item expanded"><a href=shell.html><strong aria-hidden=true>6.</strong> Shell</a><li class="chapter-item expanded"><a href=shell-scripting.html><strong aria-hidden=true>7.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>8.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=text-processing><a class=header href=#text-processing>Text Processing</a></h1><p>Many CLI text processing tools have been in existence for about half a century. And newer tools are being written to solve ever expanding text processing problems. Just knowing that a particular tool exists or searching for a tool before attempting to write your own solution can be a time saver. Also, popular tools are likely to be optimized for speed, hardened against bugs from wide usage and so on.<h2 id=sort><a class=header href=#sort>sort</a></h2><p>As the name implies, this command is used to sort contents of input files. How about alphabetic sort and numeric sort? Possible. How about sorting a particular column? Possible. Prioritized multiple sorting order? Possible. Randomize? Unique? Lot of such features supported by this powerful command.<p><strong>Options</strong><ul><li><code>-n</code> sort numerically<li><code>-V</code> version sort, aware of numbers within text<li><code>-h</code> sort human readable numbers like 4K, 3M, etc<li><code>-k</code> sort via key (column sorting)<li><code>-t</code> use SEP instead of non-blank to blank transition<li><code>-u</code> sort uniquely<li><code>-R</code> random sort<li><code>-r</code> reverse the sort order<li><code>-o</code> redirect sorted result to specified filename, useful to sort a file inplace</ul><p><strong>Examples</strong><p>Sorting based on whole line content:<pre><code class=language-bash># default sort 
$ printf 'banana\ncherry\napple' | sort
apple
banana
cherry

# reverse the output
$ printf 'peace\nrest\nquiet' | sort -r
rest
quiet
peace

# numerical sort
$ printf '20\n2\n3' | sort -n
2
3
20

# sorting human readable numbers
$ sort -hr file_size.txt
1.4G    games
316M    projects
746K    report.log
104K    power.log
20K     sample.txt

# version sort
$ sort -V timings.txt
3m20.058s
3m42.833s
4m3.083s
4m11.130s
5m35.363s

# unique sort, ignore case differences
$ printf 'CAT\nbat\ncat\ncar\nbat\n' | sort -fu
bat
car
CAT
</code></pre><p>Sorting based on columns:<pre><code class=language-bash>$ cat shopping.txt
apple   50
toys    5
Pizza   2
mango   25
Banana  10

# sort based on 2nd column numbers
$ sort -k2,2n shopping.txt
Pizza   2
toys    5
Banana  10
mango   25
apple   50
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/sort?sort=votes&pageSize=15>sort Q&A on unix stackexchange</a><li><a href=https://unix.stackexchange.com/questions/249452/unix-multiple-column-sort-issue>sort on multiple columns using -k option</a></ul><h2 id=uniq><a class=header href=#uniq>uniq</a></h2><p>This command helps you to identify and remove duplicates. Usually requires a sorted input as the comparison is made between adjacent lines only.<p><strong>Options</strong><ul><li><code>-u</code> display only the unique entries<li><code>-d</code> display only the duplicate entries<li><code>-D</code> display all the copies of duplicates<li><code>-c</code> prefix count<li><code>-i</code> ignore case while determining duplicates<li><code>-f</code> skip first <code>N</code> fields <ul><li>field separation is based on one or more space/tab characters only</ul><li><code>-s</code> skip first <code>N</code> characters<li><code>-w</code> restricts the comparison to the first <code>N</code> characters</ul><p><strong>Examples</strong><p>Default <code>uniq</code> retains only one copy of duplicate lines:<pre><code class=language-bash># same as sort -u for this case
$ printf 'red\nred\nred\ngreen\nred\nblue\nblue' | sort | uniq
blue
green
red

# can't use sort -n -u here
$ printf '2 balls\n13 pens\n2 pins\n13 pens\n' | sort -n | uniq
2 balls
2 pins
13 pens
</code></pre><p>Get unique and duplicate entries:<pre><code class=language-bash>$ cat purchases.txt
coffee
tea
washing powder
coffee
toothpaste
tea
soap
tea

$ sort purchases.txt | uniq -u
soap
toothpaste
washing powder

$ sort purchases.txt | uniq -d
coffee
tea

$ sort purchases.txt | uniq -D
coffee
coffee
tea
tea
tea
</code></pre><p>Count prefix:<pre><code class=language-bash>$ sort purchases.txt | uniq -c
      2 coffee
      1 soap
      3 tea
      1 toothpaste
      1 washing powder

$ sort purchases.txt | uniq -dc
      2 coffee
      3 tea

# sorting by number of occurrences
$ sort purchases.txt | uniq -c | sort -nr
      3 tea
      2 coffee
      1 washing powder
      1 toothpaste
      1 soap
</code></pre><p>Based on columns:<pre><code class=language-bash># compare only first 2 characters
$ printf '1) apple\n1) almond\n2) banana\n3) cherry' | uniq -w2
1) apple
2) banana
3) cherry

# skip first field
# then skip first two characters (including the blank character)
# use next two characters for comparison ('bl' and 'ch' in this example)
$ printf '2 @blue\n10 :black\n5 :cherry\n3 @chalk' | uniq -f1 -s2 -w2
2 @blue
5 :cherry
</code></pre><h2 id=comm><a class=header href=#comm>comm</a></h2><p>The <code>comm</code> command finds common and unique lines between two sorted files. These results are formatted as a table with three columns and one or more of these columns can be suppressed as required.<p><strong>Options</strong><ul><li><code>-1</code> to suppress lines unique to the first file<li><code>-2</code> to suppress lines unique to the second file<li><code>-3</code> to suppress lines common to both the files</ul><p><strong>Examples</strong><pre><code class=language-bash># side by side view of already sorted sample files
$ paste colors_1.txt colors_2.txt
Blue    Black
Brown   Blue
Orange  Green
Purple  Orange
Red     Pink
Teal    Red
White   White

# default three column output
$ comm colors_1.txt colors_2.txt
        Black
                Blue
Brown
        Green
                Orange
        Pink
Purple
                Red
Teal
                White

# only the common lines
$ comm -12 colors_1.txt colors_2.txt
Blue
Orange
Red
White

# lines unique to the second file
$ comm -13 colors_1.txt colors_2.txt
Black
Green
Pink
</code></pre><h2 id=seq><a class=header href=#seq>seq</a></h2><p>The <code>seq</code> command is a handy tool to generate a sequence of numbers in ascending or descending order. Both integer and floating-point numbers are supported. You can also customize the formatting for numbers and the separator between them.<p>You need three numbers to generate an arithmetic progression — <strong>start</strong>, <strong>step</strong> and <strong>stop</strong>. When you pass only a single number as the stop value, the default start and step values are assumed to be <code>1</code>. Passing two numbers are considered as start and stop values (in that order).<pre><code class=language-bash># start=1, step=1 and stop=3
$ seq 3
1
2
3

# start=25434, step=1 and stop=25437
$ seq 25434 25437
25434
25435
25436
25437

# start=-5, step=1 and stop=-3
$ seq -5 -3
-5
-4
-3

# start=0.25, step=0.33 and stop=1.12
$ seq 0.25 0.33 1.12
0.25
0.58
0.91
</code></pre><p>By using a negative step value, you can generate sequences in descending order.<pre><code class=language-bash>$ seq 3 -1 1
3
2
1
</code></pre><p>You can use the <code>-s</code> option to change the separator between the numbers of a sequence.<pre><code class=language-bash>$ seq -s' - ' 4
1 - 2 - 3 - 4

$ seq -s: 1.2e2 0.752 1.22e2
120.000:120.752:121.504
</code></pre><p>The <code>-w</code> option will equalize the width of the output numbers using leading zeros. The largest width between the start and stop values will be used.<pre><code class=language-bash>$ seq -w 8 10
08
09
10

$ seq -w 0003
0001
0002
0003
</code></pre><p>You can use the <code>-f</code> option for <code>printf</code> style floating-point number formatting.<pre><code class=language-bash>$ seq -f'%g' -s: 1 0.75 3
1:1.75:2.5

$ seq -f'%.4f' -s: 1 0.75 3
1.0000:1.7500:2.5000

$ seq -f'%.3e' 1.2e2 0.752 1.22e2
1.200e+02
1.208e+02
1.215e+02
</code></pre><h2 id=cmp><a class=header href=#cmp>cmp</a></h2><p>The <code>cmp</code> command is useful to compare text and binary files. If the two files are same, no output is displayed and exit status is <code>0</code>. If there is a difference, it prints the first difference with details like line number and byte location and exit status will be <code>1</code>. You can use <code>-s</code> option to suppress the output if you just need to rely on the exit status. The <code>-i</code> option will allow you to skip initial bytes from the input.<pre><code class=language-bash>$ echo 'hello' > f1.txt
$ echo 'hello' > f2.txt
$ echo 'hello.' > f3.txt

# files with same content
$ cmp f1.txt f2.txt
$ echo $?
0

# files with differences
$ cmp f1.txt f3.txt
f1.txt f3.txt differ: byte 6, line 1
$ echo $?
1
</code></pre><h2 id=diff><a class=header href=#diff>diff</a></h2><p>Useful to find differences between text files. All the differences are printed, which might not be desirable for long files.<p><strong>Options</strong><ul><li><code>-i</code> ignore case while comparing<li><code>-w</code> ignore white-spaces<li><code>-b</code> ignore changes in the amount of white space<li><code>-B</code> ignore only blank lines<li><code>-E</code> ignore changes due to tab expansion<li><code>-z</code> ignore trailing white spaces at end of line<li><code>-y</code> two column output<li><code>-r</code> recursively compare files between the two directories specified<li><code>-s</code> convey message when two files are same<li><code>-q</code> report if files differ, not the details of difference</ul><p><strong>Examples</strong><p><code>diff</code> output shows lines from the first file input starting with <code><</code> and lines from the second file input starts with <code>></code>. Between the two file contents, <code>---</code> is used as the separator. Each difference is prefixed by a command that indicates the differences.<pre><code class=language-bash>$ paste f1.txt f2.txt
1       1
2       hello
3       3
world   4

$ diff f1.txt f2.txt
2c2
< 2
---
> hello
4c4
< world
---
> 4

$ diff <(seq 4) <(seq 5)
4a5
> 5
</code></pre><p>Ignoring difference in white spaces:<pre><code class=language-bash># ignore changes in the amount of white space
$ diff -b <(echo 'good day') <(echo 'good    day')
$ echo $?
0

# ignore all white spaces
$ diff -w <(echo 'hi    there ') <(echo ' hi there')
$ echo $?
0
$ diff -w <(echo 'hi    there ') <(echo 'hithere')
$ echo $?
0
</code></pre><p>Side-by-side output:<pre><code class=language-bash>$ diff -y f1.txt f2.txt
1                                                               1
2                                                             | hello
3                                                               3
world                                                         | 4

# -y is usually used along with other options
# default width is 130 print columns
$ diff -W 60 --suppress-common-lines -y d1 d2
2                            |  hello
world                        |  4
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/diff?sort=votes&pageSize=15>diff Q&A on unix stackexchange</a><li><code>gvimdiff</code> edit two, three or four versions of a file with GVim and show differences<li><a href=http://askubuntu.com/questions/2946/what-are-some-good-gui-diff-and-merge-applications-available-for-ubuntu>GUI diff and merge tools</a></ul><h2 id=tr><a class=header href=#tr>tr</a></h2><p><code>tr</code> helps you to map one set of characters to another set of characters. Features like range, repeats, character sets, squeeze, complement, etc makes it a must know text processing tool.<p><strong>Options</strong><ul><li><code>-d</code> specify a set of characters to be deleted<li><code>-c</code> invert the first set of characters<li><code>-s</code> squeeze consecutive repeated characters to a single copy of that character</ul><p><strong>Examples</strong><p><code>tr</code> works only on <code>stdin</code> data, so use shell input redirection for file input.<pre><code class=language-bash># 'l' maps to '1', 'e' to '3', 't' to '7' and 's' to '5'
$ echo 'leet speak' | tr 'lets' '1375'
1337 5p3ak

# example with shell metacharacters
$ echo 'apple;banana;cherry' | tr ';' ':'
apple:banana:cherry

# swap case
$ echo 'Hello World' | tr 'a-zA-Z' 'A-Za-z'
hELLO wORLD

$ tr 'a-z' 'A-Z' &LTgreeting.txt
HI THERE
HAVE A NICE DAY
</code></pre><p>Examples for <code>-d</code> and <code>-c</code> options:<pre><code class=language-bash>$ echo '2021-08-12' | tr -d '-'
20210812

$ s='"Hi", there! How *are* you? All fine here.'
$ echo "$s" | tr -d '[:punct:]'
Hi there How are you All fine here

# retain alphabets, whitespaces, period, exclamation and question mark
$ echo "$s" | tr -cd 'a-zA-Z.!?[:space:]'
Hi there! How are you? All fine here.
</code></pre><p>Examples for <code>-s</code> option:<pre><code class=language-bash># squeeze lowercase alphabets
$ echo 'hhoowwww aaaaaareeeeee yyouuuu!!' | tr -s 'a-z'
how are you!!

# translate and squeeze
$ echo 'hhoowwww aaaaaareeeeee yyouuuu!!' | tr -s 'a-z' 'A-Z'
HOW ARE YOU!!

# delete and squeeze
$ echo 'hhoowwww aaaaaareeeeee yyouuuu!!' | tr -sd '!' 'a-z'
how are you

# squeeze other than lowercase alphabets
$ echo 'how    are     you!!!!!' | tr -cs 'a-z'
how are you!
</code></pre><h2 id=sed><a class=header href=#sed>sed</a></h2><p>The command name <code>sed</code> is derived from <strong>s</strong>tream <strong>ed</strong>itor. Here, stream refers to data being passed via shell pipes. Thus, the command's primary functionality is to act as a text editor for <strong>stdin</strong> data with <strong>stdout</strong> as the output target. You can also edit file input and save the changes back to the same file if needed.<p><code>sed</code> has various commands to manipulate text input. <strong>substitute</strong> command is most commonly used, whose syntax is <code>s/REGEXP/REPLACEMENT/FLAGS</code>.<pre><code class=language-bash># for each input line, change only the first ',' to '-'
$ printf '1,2,3,4\na,b,c,d\n' | sed 's/,/-/'
1-2,3,4
a-b,c,d

# change all matches by adding the 'g' flag
$ printf '1,2,3,4\na,b,c,d\n' | sed 's/,/-/g'
1-2-3-4
a-b-c-d

# example with file input
$ cat greeting.txt
Hi there
Have a nice day
# change first occurrence of 'day' with 'weekend'
$ sed 's/day/weekend/' greeting.txt
Hi there
Have a nice weekend
</code></pre><p>You can use the <code>-i</code> option for inplace editing. Pass an argument to this option to save the original input as a backup.<pre><code class=language-bash>$ cat colors.txt
deep blue
light orange
blue delight

# output from sed is written back to 'colors.txt'
# original file is preserved in 'colors.txt.bkp'
$ sed -i.bkp 's/blue/green/' colors.txt
$ cat colors.txt
deep green
light orange
green delight
</code></pre><p><code>sed</code> also has features to filter the lines like <code>grep</code>. And you can apply other <code>sed</code> commands for these filtered lines as needed.<pre><code class=language-bash># -n disables automatic printing
# 'p' command prints matching lines, same as: grep 'a'
$ printf 'sea\neat\ndrop\n' | sed -n '/a/p'
sea
eat

# 'd' command deletes matching lines, same as: grep -v 'at'
$ printf 'sea\neat\ndrop\n' | sed '/at/d'
sea
drop

# change commas to hyphens only if the input line contains '2'
$ printf '1,2,3,4\na,b,c,d\n' | sed '/2/ s/,/-/g'
1-2-3-4
a,b,c,d

# change commas to hyphens if the input line does NOT contain '2'
$ printf '1,2,3,4\na,b,c,d\n' | sed '/2/! s/,/-/g'
1,2,3,4
a-b-c-d
</code></pre><p>You can use <code>q</code> and <code>Q</code> commands to quit <code>sed</code> once a matching line is found:<pre><code class=language-bash># quit after a line containing 'st' is found
$ printf 'apple\nsea\neast\ndust' | sed '/st/q'
apple
sea
east

# matching line won't be printed in this case
$ printf 'apple\nsea\neast\ndust' | sed '/st/Q'
apple
sea
</code></pre><p>Apart from regexp, filtering can also be done based on line numbers, address range, etc.<pre><code class=language-bash># substitution only on 2nd line, use '$' to indicate last input line
$ printf 'gates\nnot\nused\n' | sed '2 s/t/*/g'
gates
no*
used

# address range, same as: sed -n '3,8!p'
# you can also use regexp as filtering criteria
$ seq 15 24 | sed '3,8d'
15
16
23
24
</code></pre><p>Here are some regexp based substitution examples, how to use alternate delimiters, etc. The <code>-E</code> option enables <code>ERE</code> (default is <code>BRE</code>).<pre><code class=language-bash># replace all sequences of non-digits with '-'
$ echo 'Sample123string42with777numbers' | sed -E 's/[^0-9]+/-/g'
-123-42-777-

# replace numbers >= 100 with optional leading zeros
$ echo '0501 035 154 12 26 98234' | sed -E 's/\b0*[1-9][0-9]{2,}\b/X/g'
X 035 X 12 26 X

# reduce \\ to single \ and delete if it is a single \
$ echo '\[\] and \\w and \[a-zA-Z0-9\_\]' | sed -E 's/(\\?)\\/\1/g'
[] and \w and [a-zA-Z0-9_]

# remove two or more duplicate words separated by space
# \b prevents false matches like 'the theatre', 'sand and stone' etc
$ echo 'aa a a a 42 f_1 f_1 f_13.14' | sed -E 's/\b(\w+)( \1)+\b/\1/g'
aa a 42 f_1 f_13.14

# & backreferences the matched character, \u changes it to uppercase
$ echo 'hello there. how are you?' | sed 's/\b\w/\u&/g'
Hello There. How Are You?

# replace only the third matching occurrence
$ echo 'foo:123:bar:baz' | sed 's/:/-/3'
foo:123:bar-baz

$ echo '/home/learnbyexample/reports' | sed 's#/home/learnbyexample/#~/#'
~/reports
$ echo 'home path is:' | sed 's|$| '"${HOME}"'|'
home path is: /home/learnbyexample
</code></pre><p><strong>Further Reading</strong><ul><li>My ebook <a href=https://github.com/learnbyexample/learn_gnused>GNU SED</a> <ul><li>See also my blog post <a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>GNU BRE/ERE cheatsheet</a></ul><li><a href=https://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files>unix.stackexchange: common search and replace examples with sed and other tools</a><li><a href=https://unix.stackexchange.com/questions/tagged/sed?sort=votes&pageSize=15>sed Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/sed?sort=votes&pageSize=15>sed Q&A on stackoverflow</a></ul><h2 id=awk><a class=header href=#awk>awk</a></h2><p><code>awk</code> provides filtering capabilities like those supported by <code>grep</code> and <code>sed</code> plus some nifty features. And similar to many command line utilities, <code>awk</code> can accept input from both <code>stdin</code> and files.<ul><li><code>awk '/regexp/'</code> is a shortcut for <code>awk '$0 ~ /regexp/{print $0}'</code><li><code>awk '!/regexp/'</code> is a shortcut for <code>awk '$0 !~ /regexp/{print $0}'</code></ul><pre><code class=language-bash># same as: grep 'at' and sed -n '/at/p'
$ printf 'gate\napple\nwhat\nkite\n' | awk '/at/'
gate
what

# same as: grep -v 'e' and sed -n '/e/!p'
$ printf 'gate\napple\nwhat\nkite\n' | awk '!/e/'
what
</code></pre><p><code>awk</code> is primarily used for field based processing. Some special variables:<ul><li><code>$0</code> contains input record content<li><code>$1</code> first field<li><code>$2</code> second field and so on<li><code>NF</code> number of fields<li><code>NR</code> number of records (i.e. line number)</ul><pre><code class=language-bash>$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14

# print the second field of each input line
$ awk '{print $2}' table.txt
bread
cake
banana

# print lines only if the last field is a negative number
$ awk '$NF&LT0' table.txt
blue cake mug shirt -7

# change 'b' to 'B' only for the first field
# gsub() is like sed with 'g' flag, sub() is without 'g' flag
$ awk '{gsub(/b/, "B", $1)} 1' table.txt
Brown bread mat hair 42
Blue cake mug shirt -7
yellow banana window shoes 3.14
</code></pre><p>The examples in previous sections used a few different ways to construct a typical <code>awk</code> one-liner. If you haven't yet grasped the syntax, this generic structure might help:<p><code>awk 'cond1{action1} cond2{action2} ... condN{actionN}'</code><p>If a condition isn't provided, the action is always executed. Within a block, you can provide multiple statements separated by semicolon character. If action isn't provided, then by default, contents of <code>$0</code> variable is printed if the condition evaluates to <code>true</code>. When action isn't present, you can use semicolon to terminate a condition and start another <code>condX{actionX}</code> snippet.<p>You can use a <code>BEGIN{}</code> block when you need to execute something before the input is read and a <code>END{}</code> block to execute something after all of the input has been processed.<pre><code class=language-bash>$ seq 2 | awk 'BEGIN{print "---"} 1; END{print "%%%"}'
---
1
2
%%%
</code></pre><p>As seen earlier, <code>awk</code> automatically splits input into fields (based on space/tab/newline characters) which are accessible using <code>$N</code> where <code>N</code> is the field number you need. You can use the <code>-F</code> option or <code>FS</code> variable to set a regexp based field separator. Use <code>OFS</code> variable to set the output field separator. You can use <code>FPAT</code> to define what characters should make up the fields instead of using <code>FS</code> to split the input record.<pre><code class=language-bash>$ echo 'goal:amazing:whistle:kwality' | awk -F: '{print $1}'
goal
$ echo 'Sample123string42with777numbers' | awk -F'[a-zA-Z]+' '{print $2}'
123

$ s='Sample123string42with777numbers'
$ echo "$s" | awk -F'[0-9]+' -v OFS=, '{print $1, $(NF-1)}'
Sample,with

$ s='eagle,"fox,42",bee,frog'
$ echo "$s" | awk -v FPAT='"[^"]*"|[^,]*' '{print $2}'
"fox,42"
</code></pre><p>By default, newline is used as input and output record separators. You can change them using <code>RS</code> and <code>ORS</code> variables.<pre><code class=language-bash># print records containing 'i' and 't'
$ printf 'Sample123string42with777numbers' | awk -v RS='[0-9]+' '/i/ && /t/'
string
with

# empty RS is paragraph mode, uses two or more newlines as separator
$ printf 'apple\nbanana\n\n123\n456' | awk -v RS= 'NR==1'
apple
banana

# change ORS depending on some condition
$ seq 6 | awk '{ORS = NR%3 ? "-" : "\n"} 1'
1-2-3
4-5-6
</code></pre><p>The <code>condX{actionX}</code> shortcut makes it easy to code state machines concisely, which is useful to solve multiple record use cases.<pre><code class=language-bash># match and print two consecutive records
# first record should contain 'as' and second record should contain 'not'
$ awk 'p ~ /as/ && /not/{print p ORS $0} {p=$0}' programming_quotes.txt
Therefore, if you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it by Brian W. Kernighan

# same as: grep --no-group-separator -A1 'blue'
# print matching line as well as the one that follows it
$ awk '/blue/{n=2} n && n--' context.txt
blue
    toy
light blue
    flower
</code></pre><p>Processing records bounded by distinct markers:<pre><code class=language-bash>$ awk '/start/{f=1} f; /end/{f=0}' uniform.txt
--start 1--
1234
6789
**end 1**

# you can re-arrange and invert the conditions to create other combinations
# for example, exclude ending match
$ awk '/start/{f=1} /end/{f=0} f' uniform.txt
--start 1--
1234
6789
</code></pre><p>The <em>key</em> features used in the solution below:<ul><li>For two files as input, <code>NR==FNR</code> will be <code>true</code> only when the first file is being processed (<code>FNR</code> is record number like <code>NR</code> but resets for each input file)<li><code>next</code> will skip rest of code and fetch next record<li><code>a[$0]</code> by itself is a valid statement. It will create an uninitialized element in array <code>a</code> with <code>$0</code> as the key (assuming the key doesn't exist yet)<li><code>$0 in a</code> checks if the given string (<code>$0</code> here) exists as a key in array <code>a</code></ul><blockquote><p><img src=images/warning.svg alt=warning> Note that the <code>NR==FNR</code> logic will fail if the first file is empty. See <a href=https://unix.stackexchange.com/a/237110/109046>this unix.stackexchange thread</a> for workarounds.</blockquote><pre><code class=language-bash># common lines
# same as: grep -Fxf color1.txt color2.txt
$ awk 'NR==FNR{a[$0]; next} $0 in a' color1.txt color2.txt
light blue
yellow
</code></pre><p><code>awk '!a[$0]++'</code> is one of the most famous <code>awk</code> one-liners. It eliminates line based duplicates while retaining input order. The following example shows it in action along with an illustration of how the logic works.<pre><code class=language-bash>$ cat purchases.txt
coffee
tea
washing powder
coffee
toothpaste
tea
soap
tea

$ awk '{print +a[$0] "\t" $0; a[$0]++}' purchases.txt
0       coffee
0       tea
0       washing powder
1       coffee
0       toothpaste
1       tea
0       soap
2       tea

# only those entries with zero in first column will be retained
$ awk '!a[$0]++' purchases.txt
coffee
tea
washing powder
toothpaste
soap
</code></pre><p><strong>Further Reading</strong><ul><li>My ebook <a href=https://github.com/learnbyexample/learn_gnuawk>GNU AWK</a> <ul><li>See also my blog post <a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>GNU BRE/ERE cheatsheet</a></ul><li><a href=https://www.gnu.org/software/gawk/manual/>Online gawk manual</a><li><a href=https://unix.stackexchange.com/questions/tagged/awk?sort=votes&pageSize=15>awk Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/awk?sort=votes&pageSize=15>awk Q&A on stackoverflow</a></ul><h2 id=perl><a class=header href=#perl>perl</a></h2><p><code>perl</code> one-liners can be used for filtering lines matched by a regexp, similar to <code>grep</code>, <code>sed</code> and <code>awk</code>. And similar to many command line utilities, <code>perl</code> can accept input from both <code>stdin</code> and file arguments.<pre><code class=language-bash># print all lines containing 'at'
# same as: grep 'at' and sed -n '/at/p' and awk '/at/'
$ printf 'gate\napple\nwhat\nkite\n' | perl -ne 'print if /at/'
gate
what

# print all lines NOT containing 'e'
# same as: grep -v 'e' and sed -n '/e/!p' and awk '!/e/'
$ printf 'gate\napple\nwhat\nkite\n' | perl -ne 'print if !/e/'
what
</code></pre><p>The <code>-e</code> option accepts code as command line argument. Many shortcuts are available to reduce the amount of typing needed. In the above examples, a regular expression has been used to filter the input. When the input string isn't specified, the test is performed against special variable <code>$_</code>, which has the contents of the current input line here. <code>$_</code> is also the default argument for many functions like <code>print</code> and <code>say</code>. To summarize:<ul><li><code>/REGEXP/FLAGS</code> is a shortcut for <code>$_ =~ m/REGEXP/FLAGS</code><li><code>!/REGEXP/FLAGS</code> is a shortcut for <code>$_ !~ m/REGEXP/FLAGS</code></ul><p>For the following examples, <code>-p</code> option is used instead of <code>-n</code> option, so that the value of <code>$_</code> is automatically printed after processing each input line.<pre><code class=language-bash># same as: sed 's/:/-/' and awk '{sub(/:/, "-")} 1'
$ printf '1:2:3:4\na:b:c:d\n' | perl -pe 's/:/-/'
1-2:3:4
a-b:c:d

# same as: sed 's/:/-/g' and awk '{gsub(/:/, "-")} 1'
$ printf '1:2:3:4\na:b:c:d\n' | perl -pe 's/:/-/g'
1-2-3-4
a-b-c-d
</code></pre><p>Here's some examples that is based on specific field rather than the entire line. The <code>-a</code> option will cause the input line to be split based on whitespaces and the field contents can be accessed using <code>@F</code> special array variable. Leading and trailing whitespaces will be suppressed, so there's no possibility of empty fields.<pre><code class=language-bash>$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14

# same as: awk '{print $2}' table.txt
$ perl -lane 'print $F[1]' table.txt
bread
cake
banana

# same as: awk '$NF&LT0' table.txt
$ perl -lane 'print if $F[-1] < 0' table.txt
blue cake mug shirt -7

# same as: awk '{gsub(/b/, "B", $1)} 1' table.txt
$ perl -lane '$F[0] =~ s/b/B/g; print "@F"' table.txt
Brown bread mat hair 42
Blue cake mug shirt -7
yellow banana window shoes 3.14
</code></pre><p>I reach for Perl over <code>grep</code>, <code>sed</code> and <code>awk</code> if I need the powerful regexp features and make use of the vast builtin functions and libraries. Here are some examples:<pre><code class=language-bash># reverse lowercase alphabets at the end of input lines
$ echo 'fig 22apples' | perl -pe 's/[a-z]+$/reverse $&/e'
fig 22selppa

# replace arithmetic expressions with their output
$ echo '42*10 200+100 22/7' | perl -pe 's|\d+[+/*-]\d+|$&|gee'
420 300 3.14285714285714

# exclude terms while substituting
$ s='orange apple appleseed'
$ echo "$s" | perl -pe 's#\bapple\b(*SKIP)(*F)|\w+#($&)#g'
(orange) apple (appleseed)

# fields containing 'in' or 'it' or 'is'
$ s='goal:amazing:42:whistle:kwality:3.14'
$ echo "$s" | perl -F: -lane 'print join ":", grep {/i[nts]/} @F'
amazing:whistle:kwality

# sorting
$ echo '23 756 -983 5' | perl -lane 'print join " ", sort {$a <=> $b} @F'
-983 5 23 756
$ s='floor bat to dubious four'
$ echo "$s" | perl -lane 'print join ":", sort @F'
bat:dubious:floor:four:to

# unique fields, maintains input order of elements
$ s='3,b,a,3,c,d,1,d,c,2,2,2,3,1,b'
$ echo "$s" | perl -MList::Util=uniq -F, -lanE 'say join ",", uniq @F'
3,b,a,c,d,1,2
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://perldoc.perl.org/perlintro>perldoc: Perl introduction</a><li><a href=https://perldoc.perl.org/perlretut>perldoc: Regexp tutorial</a><li>My ebook <a href=https://github.com/learnbyexample/learn_perl_oneliners>Perl one-liners</a></ul><h2 id=cut><a class=header href=#cut>cut</a></h2><p><code>cut</code> is a handy tool for many field processing use cases. The features are limited compared to <code>awk</code> and <code>perl</code> commands, but the reduced scope also leads to faster processing.<p>By default, <code>cut</code> splits the input content into fields based on the tab character, which you can change using the <code>-d</code> option. The <code>-f</code> option allows you to select a desired field from each input line. To extract multiple fields, specify the selections separated by the comma character. By default, lines not containing the input delimiter will still be part of the output. You can use the <code>-s</code> option to suppress such lines.<pre><code class=language-bash># second field
$ printf 'apple\tbanana\tcherry\n' | cut -f2
banana

# first and third field
$ printf 'apple\tbanana\tcherry\n' | cut -f1,3
apple   cherry

$ echo 'one;two;three;four' | cut -d';' -f3
three
</code></pre><p>You can use the <code>-</code> character to specify field ranges. You can skip the starting or ending range, but not both.<pre><code class=language-bash># 2nd, 3rd and 4th fields
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f2-4
banana  cherry  dates

# all fields from the start till the 3rd field
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f-3
apple   banana  cherry

# all fields from the 3rd field till the end
$ printf 'apple\tbanana\tcherry\tdates\n' | cut -f3-
cherry  dates
</code></pre><p>Use the <code>--output-delimiter</code> option to customize the output separator to any string of your choice.<pre><code class=language-bash># same as: tr '\t' ','
$ printf 'apple\tbanana\tcherry\n' | cut --output-delimiter=, -f1-
apple,banana,cherry

# multicharacter example
$ echo 'one;two;three;four' | cut -d';' --output-delimiter=' : ' -f1,3-
one : three : four
</code></pre><p>The <code>--complement</code> option allows you to invert the field selections.<pre><code class=language-bash># except second field
$ printf 'apple ball cat\n1 2 3 4 5' | cut --complement -d' ' -f2
apple cat
1 3 4 5

# except first and third fields
$ printf 'apple ball cat\n1 2 3 4 5' | cut --complement -d' ' -f1,3
ball
2 4 5
</code></pre><p>You can use the <code>-b</code> or <code>-c</code> options to select specified bytes from each input line. The syntax is same as the <code>-f</code> option. The <code>-c</code> option is intended for multibyte character selection, but for now it works exactly as the <code>-b</code> option.<pre><code class=language-bash>$ printf 'apple\tbanana\tcherry\n' | cut -c2,8,11
pan

$ printf 'apple\tbanana\tcherry\n' | cut -c2,8,11 --output-delimiter=-
p-a-n

$ printf 'apple\tbanana\tcherry\n' | cut --complement -c13-
apple   banana

$ printf 'cat-bat\ndog:fog\nget;pet' | cut -c5-
bat
fog
pet
</code></pre><h2 id=paste><a class=header href=#paste>paste</a></h2><p><code>paste</code> is typically used to merge two or more files column wise. It also has a handy feature for serializing data.<p>By default, <code>paste</code> adds a tab character between corresponding lines of input files.<pre><code class=language-bash>$ cat colors_1.txt
Blue
Brown
Orange
Purple
$ cat colors_2.txt
Black
Blue
Green
Orange

$ paste colors_1.txt colors_2.txt
Blue    Black
Brown   Blue
Orange  Green
Purple  Orange
</code></pre><p>You can use the <code>-d</code> option to change the delimiter between the columns. The separator is added even if the data has been exhausted for some of the input files.<pre><code class=language-bash>$ paste -d'|' <(seq 3) <(seq 4 5) <(seq 6 8)
1|4|6
2|5|7
3||8

# note that the space between -d and empty string is necessary here
$ paste -d '' <(seq 3) <(seq 6 8)
16
27
38

$ paste -d'\n' <(seq 11 12) <(seq 101 102)
11
101
12
102
</code></pre><p>If you use <code>-</code> multiple times, <code>paste</code> will consume a line from <code>stdin</code> data every time <code>-</code> is encountered. This is different from using the same filename multiple times, in which case they are treated as separate inputs.<pre><code class=language-bash># five columns
$ seq 10 | paste -d: - - - - -
1:2:3:4:5
6:7:8:9:10

# use input redirection for file input
$ &LTcolors_1.txt paste -d: - - -
Blue:Brown:Orange
Purple::
</code></pre><p>The <code>-s</code> option allows you to combine all the input lines from a file into a single line using the given delimiter. <code>paste</code> will ensure to add a final newline character even if it isn't present in the input.<pre><code class=language-bash># &LTcolors_1.txt tr '\n' ',' will give you a trailing comma
$ paste -sd, colors_1.txt
Blue,Brown,Orange,Purple

# multiple file example:
$ paste -sd: colors_1.txt colors_2.txt
Blue:Brown:Orange:Purple
Black:Blue:Green:Orange
</code></pre><h2 id=column><a class=header href=#column>column</a></h2><p>The <code>column</code> command is a nifty tool to align input data column wise. By default, whitespace is used as the input delimiter. Space character is used to align the output columns, so whitespace characters like tab will get converted to spaces.<pre><code class=language-bash>$ printf 'one two three\nfour five six\n'
one two three
four five six

$ printf 'one two three\nfour five six\n' | column -t
one   two   three
four  five  six
</code></pre><p>You can use the <code>-s</code> option to customize the input delimiter. Note that the output delimiter will still be made up of spaces only.<pre><code class=language-bash>$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

$ column -s, -t scores.csv
Name  Maths  Physics  Chemistry
Ith   100    100      100
Cy    97     98       95
Lin   78     83       80

$ printf '1:-:2:-:3\napple:-:banana:-:cherry\n' | column -s:-: -t
1      2       3
apple  banana  cherry
</code></pre><blockquote><p><img src=images/warning.svg alt=warning> Input should have a newline at the end, otherwise you'll get an error:</blockquote><pre><code class=language-bash>$ printf '1 2 3\na   b   c' | column -t
column: line too long
1  2  3
</code></pre><h2 id=pr><a class=header href=#pr>pr</a></h2><blockquote><p>Paginate or columnate FILE(s) for printing.</blockquote><p>As stated in the above quote from the manual, the <code>pr</code> command is mainly used for those two tasks. This section will discuss only the columnate features and some miscellaneous tasks. Here's a pagination example if you are interested in exploring further. The <code>pr</code> command will add blank lines, a header and so on to make it suitable for printing.<pre><code class=language-bash>$ pr greeting.txt | head


2021-08-05 14:10                   greeting.txt                   Page 1


Hi there
Have a nice day



</code></pre><p>The <code>--columns</code> and <code>-a</code> options can be used to merge the input lines in two different ways:<ul><li>split the input file and then merge them as columns<li>merge consecutive lines, similar to the <code>paste</code> command</ul><p>Here's an example to get started. Note that <code>-N</code> is same as using <code>--columns=N</code> where <code>N</code> is the number of columns you want in the output. The default page width is <code>72</code>, which means each column can only have a maximum of <code>72/N</code> characters (including the separator). Tab and space characters will be used to fill the columns as needed. You can use the <code>-J</code> option to prevent <code>pr</code> from truncating longer columns. The <code>-t</code> option is used here to turn off the pagination features.<pre><code class=language-bash># split input into three parts
# each column width is 72/3 = 24 characters max
$ seq 9 | pr -3t
1                       4                       7
2                       5                       8
3                       6                       9
</code></pre><p>You can customize the separator using the <code>-s</code> option. The default is a tab character which you can change to any other string value. The <code>-s</code> option also turns off line truncation, so <code>-J</code> option isn't needed. However, the default page width of <code>72</code> can still cause issues, which you can prevent by using the <code>-w</code> option.<pre><code class=language-bash># tab separator
$ seq 9 | pr -3ts
1       4       7
2       5       8
3       6       9

# custom separator
$ seq 9 | pr -3ts' : '
1 : 4 : 7
2 : 5 : 8
3 : 6 : 9

$ seq 6 | pr -J -w10 -3ats'::::'
pr: page width too narrow
$ seq 6 | pr -J -w11 -3ats'::::'
1::::2::::3
4::::5::::6
</code></pre><p>Use the <code>-a</code> option to merge consecutive lines, similar to the <code>paste</code> command. One advantage is that the <code>-s</code> option supports a string value, whereas with <code>paste</code> you'd need to use workarounds to get multicharacter separation.<pre><code class=language-bash># same as: paste -d: - - - -
$ seq 8 | pr -4ats:
1:2:3:4
5:6:7:8

# unlike paste, pr doesn't add separator if last row has less columns to fill
$ seq 10 | pr -4ats,
1,2,3,4
5,6,7,8
9,10
</code></pre><p>Two or more input files can be merged column wise using the <code>-m</code> option. As seen before, <code>-t</code> is needed to ignore pagination features and <code>-s</code> can be used to customize the separator.<pre><code class=language-bash># same as: paste -d' : ' <(seq 3) /dev/null /dev/null <(seq 4 6)
$ pr -mts' : ' <(seq 3) <(seq 4 6)
1 : 4
2 : 5
3 : 6
</code></pre></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=working-with-files-and-directories.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=working-with-files-and-directories.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>