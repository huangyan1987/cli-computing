<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Searching Files and Filenames - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux command line and Scripting guide for beginner to intermediate users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>1.</strong> Introduction</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=shell-features.html><strong aria-hidden=true>4.</strong> Shell features</a><li class="chapter-item expanded"><a href=viewing-part-or-whole-file-contents.html><strong aria-hidden=true>5.</strong> Viewing part or whole File contents</a><li class="chapter-item expanded"><a href=searching-files-and-filenames.html class=active><strong aria-hidden=true>6.</strong> Searching Files and Filenames</a><li class="chapter-item expanded"><a href=file-properties.html><strong aria-hidden=true>7.</strong> File Properties</a><li class="chapter-item expanded"><a href=managing-processes.html><strong aria-hidden=true>8.</strong> Managing Processes</a><li class="chapter-item expanded"><a href=multipurpose-text-processing-tools.html><strong aria-hidden=true>9.</strong> Multipurpose text processing tools</a><li class="chapter-item expanded"><a href=sorting-stuff.html><strong aria-hidden=true>10.</strong> Sorting stuff</a><li class="chapter-item expanded"><a href=comparing-files.html><strong aria-hidden=true>11.</strong> Comparing Files</a><li class="chapter-item expanded"><a href=assorted-text-processing-tools.html><strong aria-hidden=true>12.</strong> Assorted text processing tools</a><li class="chapter-item expanded"><a href=shell-scripting.html><strong aria-hidden=true>13.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>14.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=searching-files-and-filenames><a class=header href=#searching-files-and-filenames>Searching Files and Filenames</a></h1><p>In this chapter, you'll learn how to search file contents based on literal strings or regular expressions. After that, you'll learn how to locate files based on their names and other properties like size, last modified, etc.<h2 id=grep><a class=header href=#grep>grep</a></h2><p>Quoting from <a href=https://en.wikipedia.org/wiki/Grep>wikipedia</a>:<blockquote><p><strong><code>grep</code></strong> is a command-line utility for searching plain-text data sets for lines that match a regular expression. Its name comes from the <code>ed</code> command <code>g/re/p</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint), which has the same effect.</blockquote><p>The <code>grep</code> command has lots and lots of features, so much so that I wrote <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>a book</a> about it. The most common usage is filtering lines from the input using a regular expression (regexp).<p><strong>Options</strong><ul><li><code>--color=auto</code> highlight the matching portions, filenames, line numbers, etc using colors<li><code>-i</code> ignore case while matching<li><code>-v</code> print non-matching lines<li><code>-n</code> prefix line numbers for matching lines<li><code>-c</code> display only the count of number of matching lines<li><code>-l</code> print only the filenames matching the given expression<li><code>-L</code> print filenames NOT matching the pattern<li><code>-w</code> match pattern only as whole words<li><code>-x</code> match pattern only as whole lines<li><code>-F</code> interpret pattern as a fixed string (i.e. not a regular expression)<li><code>-o</code> print only matching parts<li><code>-A N</code> print matching line and <code>N</code> number of lines after the matched line<li><code>-B N</code> print matching line and <code>N</code> number of lines before the matched line<li><code>-C N</code> print matching line and <code>N</code> number of lines before and after the matched line<li><code>-m N</code> print a maximum of <code>N</code> matching lines<li><code>-q</code> no standard output, quit immediately if match found, useful in scripts<li><code>-s</code> suppress error messages, useful in scripts<li><code>-r</code> recursively search all files in the specified input folders (by default searches current directory)<li><code>-R</code> like <code>-r</code>, but follows symbolic links as well<li><code>-h</code> do not prefix filename for matching lines (default behavior for single input file)<li><code>-H</code> prefix filename for matching lines (default behavior for multiple input files)</ul><p><strong>Examples</strong><p>All of the following examples would be suited for <code>-F</code> option as these do not use regular expressions. <code>grep</code> is smart enough to do the right thing in such cases.<pre><code class=language-bash># lines containing 'an'
$ printf 'apple\nbanana\nmango' | grep 'an'
banana
mango

# case insensitive matching
$ printf 'Cat\ncut\ncOnCaT\n' | grep -i 'cat'
Cat
cOnCaT

# match only whole words
$ printf 'par value\nheir apparent\n' | grep -w 'par'
par value

# count empty lines
$ printf 'hi\n\nhello\n\n\n\nbye\n' | grep -cx ''
4

# matching line and two lines after
$ printf 'red\nblue\ngreen\nbrown\nyellow' | grep -A2 'blue'
blue
green
brown
</code></pre><p>Here's an example with line numbers and matched portions in color:<p align=center><img src=images/grep_color.png alt="example with --color option"><p><strong>Regular Expressions</strong><p>By default, <code>grep</code> treats the search pattern as Basic Regular Expression (BRE)<ul><li><code>-G</code> option can be used to specify explicitly that BRE is needed<li><code>-E</code> option will enable Extended Regular Expression (ERE) <ul><li>in <code>GNU grep</code>, BRE and ERE only differ in how metacharacters are specified, no difference in features</ul><li><code>-F</code> option will cause the search patterns to be treated literally<li><code>-P</code> if available, this option will enable Perl Compatible Regular Expression (PCRE)</ul><p>The following reference is for <strong>Extended Regular Expressions</strong>.<p><strong>Anchors</strong><ul><li><code>^</code> restricts the match to the start of the string<li><code>$</code> restricts the match to the end of the string<li><code>\<</code> restricts the match to the start of word<li><code>\></code> restricts the match to the end of word<li><code>\b</code> restricts the match to the start/end of words<li><code>\B</code> matches wherever <code>\b</code> doesn't match</ul><p><strong>Dot metacharacter and Quantifiers</strong><ul><li><code>.</code> match any character, including the newline character<li><code>?</code> match <code>0</code> or <code>1</code> times<li><code>*</code> match <code>0</code> or more times<li><code>+</code> match <code>1</code> or more times<li><code>{m,n}</code> match <code>m</code> to <code>n</code> times<li><code>{m,}</code> match at least <code>m</code> times<li><code>{,n}</code> match up to <code>n</code> times (including <code>0</code> times)<li><code>{n}</code> match exactly <code>n</code> times</ul><p><strong>Character classes</strong><ul><li><code>[set123]</code> match any of these characters once<li><code>[^set123]</code> match except any of these characters once<li><code>[3-7AM-X]</code> range of characters from <code>3</code> to <code>7</code>, <code>A</code>, another range from <code>M</code> to <code>X</code><li><code>\w</code> similar to <code>[a-zA-Z0-9_]</code> for matching word characters<li><code>\s</code> similar to <code>[ \t\n\r\f\v]</code> for matching whitespace characters<li><code>\W</code> match non-word characters<li><code>\S</code> match non-whitespace characters<li><code>[[:digit:]]</code> similar to <code>[0-9]</code><li><code>[[:alnum:]_]</code> similar to <code>\w</code> <ul><li>see <a href=https://www.gnu.org/software/grep/manual/grep.html#Character-Classes-and-Bracket-Expressions>grep manual</a> for full list</ul></ul><p><strong>Alternation and Grouping</strong><ul><li><code>pat1|pat2|pat3</code> match <code>pat1</code> or <code>pat2</code> or <code>pat3</code><li><code>()</code> group patterns, <code>a(b|c)d</code> is same as <code>abd|acd</code> <ul><li>also serves as a capture group</ul><li><code>\N</code> backreference, gives matched portion of <code>N</code>th capture group <ul><li><code>\1</code> backreference to the first capture group<li><code>\2</code> backreference to the second capture group and so on up to <code>\9</code></ul></ul><p>Quoting from the manual for BRE vs ERE differences:<blockquote><p>In basic regular expressions the meta-characters <code>?</code>, <code>+</code>, <code>{</code>, <code>|</code>, <code>(</code>, and <code>)</code> lose their special meaning; instead use the backslashed versions <code>\?</code>, <code>\+</code>, <code>\{</code>, <code>\|</code>, <code>\(</code>, and <code>\)</code>.</blockquote><p><strong>Examples</strong><pre><code class=language-bash># lines ending with 'ar'
$ printf 'spared no one\npar\nspar\ndare' | grep 'ar$'
par
spar

# extract 'part' or 'parrot' or 'parent' case insensitively
$ echo 'par apartment PARROT parent' | grep -ioE 'par(en|ro)?t'
part
PARROT
parent

# extract quoted text
$ echo 'I like "mango" and "guava"' | grep -oE '"[^"]+"'
"mango"
"guava"

# 8 character lines having same 3 lowercase letters at start and end
$ grep -xE '([a-z]{3})..\1' /usr/share/dict/words
mesdames
respires
restores
testates
</code></pre><p>The <code>-f</code> and <code>-x</code> options can be combined to get common lines between two files or the difference when <code>-v</code> is used as well. Add <code>-F</code> if you want to treat the search strings literally (recall that regexp is the default).<pre><code class=language-bash>$ printf 'teal\nlight blue\nbrown\nyellow\n' > colors_1
$ printf 'blue\nblack\ndark green\nyellow\n' > colors_2

# common lines between two files
$ grep -Fxf colors_1 colors_2
yellow

# lines present in colors_2 but not in colors_1
$ grep -Fvxf colors_1 colors_2
blue
black
dark green

# lines present in colors_1 but not in colors_2
$ grep -Fvxf colors_2 colors_1
teal
light blue
brown
</code></pre><p><strong>Perl Compatible Regular Expression</strong><p>PCRE has lot more features compared to BRE/ERE. Here are some examples:<pre><code class=language-bash># numbers >= 100, uses possessive quantifiers
$ echo '0501 035 154 12 26 98234' | grep -oP '0*+\d{3,}'
0501
154
98234

# extract digits only if preceded by =
$ echo '100 foo=42, bar=314' | grep -oP '=\K\d+'
42
314

# all digits and optional hyphen combo from the start of string
$ echo '123-87-593 42 foo' | grep -oP '\G\d+-?'
123-
87-
593

# all whole words except 'bat' and 'map'
$ echo 'car bat cod map combat' | grep -oP '\b(bat|map)\b(*SKIP)(*F)|\w+'
car
cod
combat
</code></pre><p><strong>Further Reading</strong><ul><li>My ebook <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>GNU GREP and RIPGREP</a> <ul><li>See also my blog post <a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>GNU BRE/ERE cheatsheet</a></ul><li><a href=https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html>Why GNU grep is fast</a><li><a href=https://stackoverflow.com/questions/tagged/grep?sort=votes&pageSize=15>grep Q&A on stackoverflow</a><li><a href=https://unix.stackexchange.com/questions/tagged/grep?sort=votes&pageSize=15>grep Q&A on unix stackexchange</a><li><a href=https://unix.stackexchange.com/q/131535/109046>unix.stackexchange: grep -r vs find+grep</a></ul><h2 id=find><a class=header href=#find>find</a></h2><p>The <code>find</code> command has comprehensive features to narrow down files and directories based on name, size, date and so on. And more importantly, <code>find</code> helps you to perform actions on such filtered files.<p><strong>Examples</strong><p>Filtering based on filename:<p>You have to construct a pattern that covers the entire filename, be it glob (<code>-name</code> and <code>-iname</code>) or regexp (<code>-regex</code>). The path(s) to search should be specified before any options like <code>-type</code>, <code>-name</code>, etc.<ul><li><code>find</code> by default, you'll get every entry (including hidden ones) in the current directory and sub-directories<li><code>find . -name '*log'</code> only files whose name ends with <code>log</code> in the current directory and sub-directories <ul><li>the argument to <code>-name</code> is treated as a <strong>glob</strong> (i.e. wildcards, not regex)<li>specifying <code>.</code> as the search path is optional</ul><li><code>find ~/reports /etc/ -name '*.txt'</code> filenames ending with <code>.txt</code> from the paths <code>~/reports</code> and <code>/etc/</code><li><code>find -iname 'power.log'</code> files named <code>power.log</code> (ignoring case) in the current directory and sub-directories<li><code>find -not -name '*log'</code> all files whose name does NOT end with <code>log</code><li><code>find -regextype egrep -regex '.*/\w+'</code> filenames containing only word characters <code>[a-zA-Z0-9_]</code> <ul><li><code>-regextype egrep</code> sets ERE (Extended Regular Expression) as the regexp flavor (default is <code>emacs</code> flavor)<li><code>.*/</code> is needed to match till the last <code>/</code> character in the file path</ul></ul><p>Filtering based on file type:<ul><li><code>find ~/proj -type f</code> all regular files<li><code>find ~/proj -type d</code> all directories<li><code>find ~/proj -type f -name '.*'</code> only hidden files</ul><p>Filtering based on depth:<p>The path being searched is considered as depth <code>0</code>, files in sub-directory are at depth <code>1</code>, files in sub-directory of a sub-directory are at depth <code>2</code> and so on.<ul><li><code>find -maxdepth 1 -type f</code> all regular files (including hidden ones) from current directory, but not sub-directories<li><code>find -maxdepth 1 -type f -name '[^.]*'</code> all regular files (but not hidden ones) from current directory, but not sub-directories <ul><li><code>-not -name '.*'</code> can be also used</ul><li><code>find -mindepth 1 -maxdepth 1 -type d</code> all directories (including hidden ones) in current directory, but not sub-directories <ul><li><code>-mindepth 1</code> is used to exclude the path being searched, which is considered as depth <code>0</code></ul></ul><p>Filtering based on file properties:<ul><li><code>find -mtime -2</code> files that were modified within the last two days <ul><li>Note that day here means 24 hours</ul><li><code>find -mtime +7</code> files that were modified more than seven days back<li><code>find -daystart -type f -mtime -1</code> files that were modified from beginning of day (not past 24 hours)<li><code>find -size +10k</code> files with size greater than 10 kilobytes<li><code>find -size -1M</code> files with size less than 1 megabytes<li><code>find -size 2G</code> files of size 2 gigabytes</ul><p>Passing filtered files as arguments to other commands:<ul><li><code>find report -name '*log*' -exec rm {} \;</code> delete all files containing <code>log</code> anywhere in the name <ul><li>here <code>rm</code> command is called for every file matching the given condition<li>since <code>;</code> is a special shell character, it needs to be escaped using <code>\</code></ul><li><code>find report -name '*log*' -delete</code> builtin option to delete files matching the given condition<li><code>find -name '*.txt' -exec wc {} +</code> files ending with <code>.txt</code> are all passed as arguments to the <code>wc</code> command <ul><li>no need to use escape the <code>+</code> character in this case<li><strong>note</strong> that the number of invocations of the command specified is not necessarily once if the number of files found are too large</ul><li><code>find -name '*.log' -exec mv {} ../log/ \;</code> move files ending with <code>.log</code> to the <code>log</code> directory present in one hierarchy above <ul><li><code>mv</code> is executed once per each filtered file</ul><li><code>find -name '*.log' -exec mv -t ../log/ {} +</code> the <code>-t</code> option allows to specify target directory, so you can use <code>+</code> instead of having to call <code>mv</code> once for each file found <ul><li>similarly, you can use <code>-t</code> for the <code>cp</code> command</ul></ul><p><strong>Further Reading</strong><ul><li><a href=https://mywiki.wooledge.org/UsingFind>mywiki.wooledge: using find</a><li><a href=https://unix.stackexchange.com/questions/tagged/find?sort=votes&pageSize=15>find Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/find?sort=votes&pageSize=15>find Q&A on stackoverflow</a><li><a href=https://unix.stackexchange.com/q/282762/109046>unix.stackexchange: find and tar example</a><li><a href=https://unix.stackexchange.com/q/321697/109046>unix.stackexchange: Why is looping over find's output bad practice?</a></ul><h2 id=locate><a class=header href=#locate>locate</a></h2><p><code>locate</code> is a faster alternative to the <code>find</code> command for searching files by name. It is based on a database, which gets updated by a <code>cron</code> job. So, newer files may be not present in results unless you update the database. Use this command if it is available in your distro and you remember some part of filename. Very useful if you have to search the entire filesystem in which case <code>find</code> command will take a very long time compared to <code>locate</code>.<p><strong>Examples</strong><ul><li><code>locate 'power'</code> print path of filenames containing <code>power</code> in the whole filesystem <ul><li>implicitly, <code>locate</code> would change the string to <code>*power*</code> as no globbing characters are present in the string specified</ul><li><code>locate -b '\power.log'</code> print path matching the string <code>power.log</code> exactly at the end of the path <ul><li><code>/home/learnbyexample/power.log</code> matches<li><code>/home/learnbyexample/lowpower.log'</code> will not match since there are other characters at the start of the filename<li>use of <code>\</code> prevents the search string from implicitly being replaced by <code>*power.log*</code></ul><li><code>locate -b '\proj_adder'</code> the <code>-b</code> option is also handy to print only the matching directory name, otherwise every file under that folder would also be displayed</ul><blockquote><p><img src=./images/info.svg alt=info> See also <a href=https://unix.stackexchange.com/q/60205/109046>unix.stackexchange: pros and cons of find and locate</a>.</blockquote></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=viewing-part-or-whole-file-contents.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=file-properties.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=viewing-part-or-whole-file-contents.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=file-properties.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>