<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Working with Files and Directories - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux command line and Scripting guide for beginner to intermediate users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>1.</strong> Introduction</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=working-with-files-and-directories.html class=active><strong aria-hidden=true>4.</strong> Working with Files and Directories</a><li class="chapter-item expanded"><a href=text-processing.html><strong aria-hidden=true>5.</strong> Text Processing</a><li class="chapter-item expanded"><a href=shell.html><strong aria-hidden=true>6.</strong> Shell</a><li class="chapter-item expanded"><a href=shell-scripting.html><strong aria-hidden=true>7.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>8.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=working-with-files-and-directories><a class=header href=#working-with-files-and-directories>Working with Files and Directories</a></h1><p>In this chapter, you'll learn how to display contents of a file from within the terminal, filter lines from input files, search for files, get file metadata, manipulate permissions and so on.<blockquote><p><img src=./images/info.svg alt=info> See my <a href=https://github.com/learnbyexample/cli_text_processing_coreutils>Command line text processing with GNU Coreutils</a> ebook for more detailed discussion of some of the commands presented in this chapter.</blockquote><h2 id=cat><a class=header href=#cat>cat</a></h2><p>The <code>cat</code> command derives its name from con<strong>cat</strong>enate. It is primarily used to combine the contents of multiple files to be saved in a file or sent as input to another command.<p><strong>Options</strong><ul><li><code>-n</code> prefix line number and a tab character to each input line<li><code>-s</code> squeeze consecutive empty lines to a single empty line<li><code>-v</code> view special characters like NUL using the <a href=https://en.wikipedia.org/wiki/ASCII_control_characters#Control_code_chart>caret notation</a><li><code>-e</code> view special characters as well as mark the end of line<li><code>-A</code> includes <code>-e</code> and also helps to spot tab characters</ul><p><strong>Examples</strong><p>Here are some examples to showcase <code>cat</code>'s main utility. One or more files can be given as arguments.<pre><code class=language-bash># view contents of a single file
$ cat greeting.txt
Hi there
Have a nice day
$ cat fruits.txt
banana
papaya
mango

# concatenate multiple files
$ cat greeting.txt fruits.txt
Hi there
Have a nice day
banana
papaya
mango
</code></pre><p>To save the output of concatenation, use the shell's redirection features.<pre><code class=language-bash>$ cat greeting.txt fruits.txt > op.txt

$ cat op.txt
Hi there
Have a nice day
banana
papaya
mango
</code></pre><p>You can represent <code>stdin</code> data using <code>-</code> as a file argument. If file arguments are not present, <code>cat</code> will read from <code>stdin</code> data if present or wait for interactive input. Note that <code>-</code> is also supported by many more commands to indicate <code>stdin</code> data.<pre><code class=language-bash>$ echo 'apple banana cherry' | cat greeting.txt -
Hi there
Have a nice day
apple banana cherry
</code></pre><blockquote><p><img src=./images/info.svg alt=info> Using <code>cat</code> to view the contents of a file, to concatenate them, etc is well and good. But, using <code>cat</code> when it is not needed is a bad habit that you should avoid. See <a href=https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat>wikipedia: UUOC</a> and <a href=https://porkmail.org/era/unix/award.html>Useless Use of Cat Award</a> for more details.</blockquote><p><code>cat</code> is often used to spot special characters:<pre><code class=language-bash># example for backspace and carriage return
$ printf 'car\bt\nbike\rp\n'
cat
pike
$ printf 'car\bt\nbike\rp\n' | cat -v
car^Ht
bike^Mp

# example with tab characters and end-of-line marker
$ printf '1 2\t3\f4\v5   \n' | cat -A
1 2^I3^L4^K5   $
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/cat?sort=votes&pageSize=15>cat Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/cat?sort=votes&pageSize=15>cat Q&A on stackoverflow</a></ul><h2 id=tac><a class=header href=#tac>tac</a></h2><p>You can concatenate files using <code>tac</code> as well, but the output will be printed in the reverse line wise. If you pass multiple input files, each file content will be reversed separately. Here are some examples:<pre><code class=language-bash>$ printf 'apple\nbanana\ncherry\n' | tac
cherry
banana
apple

# won't be same as: cat greeting.txt fruits.txt | tac
$ tac greeting.txt fruits.txt
Have a nice day
Hi there
mango
papaya
banana
</code></pre><blockquote><p><img src=./images/warning.svg alt=warning> If the last line of input doesn't end with a newline, the output will also not have that newline character.</blockquote><pre><code class=language-bash>$ printf 'apple\nbanana\ncherry' | tac
cherrybanana
apple
</code></pre><h2 id=less><a class=header href=#less>less</a></h2><p>The <code>cat</code> command is not suitable for viewing contents of large files in the terminal. The <code>less</code> command automatically fits the content to the size of terminal, allows scrolling and has nifty features for effective viewing. Usually, <code>man</code> command uses <code>less</code> as the <code>pager</code> to display the documentation. The navigation options are similar to the <code>vi/vim</code> text editor.<p>Commonly used commands are given below. You can press the <code>h</code> key for builtin help.<ul><li><code>g</code> go to the start of the file<li><code>G</code> go to the end of the file<li><code>q</code> quit<li><code>/pattern</code> search for the given pattern in the forward direction<li><code>?pattern</code> search for the given pattern in the backward direction<li><code>n</code> go to the next match<li><code>N</code> go to the previous match</ul><p><strong>Example and Further Reading</strong><ul><li><code>less -s large_filename</code> display contents of the given file, consecutive blank lines are squeezed as a single blank line (similar to <code>cat -s</code>) <ul><li>use <code>-N</code> option to prefix line numbers</ul><li><code>less</code> command is an <a href=https://unix.stackexchange.com/q/604/109046>improved version</a> of the <code>more</code> command<li><a href=https://unix.stackexchange.com/q/81129/109046>differences between most, more and less</a><li><a href=https://unix.stackexchange.com/questions/tagged/less?sort=votes&pageSize=15>less Q&A on unix stackexchange</a></ul><h2 id=tail><a class=header href=#tail>tail</a></h2><p>By default, <code>tail</code> displays the last 10 lines of input file(s). If there are less than 10 lines in the input, only those lines will be displayed. You can use the <code>-n</code> option to change the number of lines. By using <code>tail -n +N</code>, you can get all the lines starting from the <code>N</code>th line.<pre><code class=language-bash># last two lines (input has 15 lines)
$ tail -n2 sample.txt
14) He he he
15) Adios amigo

# all lines starting from the 11th line
# space between -n and +N is optional
$ tail -n +11 sample.txt
11) mango
12) 
13) Much ado about nothing
14) He he he
15) Adios amigo
</code></pre><p>If you pass multiple input files, each file will be processed separately. By default, the output is nicely formatted with filename headers and empty line separators which you can override with the <code>-q</code> (quiet) option.<pre><code class=language-bash>$ tail -n2 fruits.txt sample.txt 
==> fruits.txt <==
papaya
banana

==> sample.txt <==
14) He he he
15) Adios amigo
</code></pre><p>The <code>-c</code> option works similar to the <code>-n</code> option, but with bytes instead of lines:<pre><code class=language-bash># last three characters
$ printf 'apple pie' | tail -c3
pie

# all characters starting from fifth character
$ printf 'car\njeep\nbus\n' | tail -c +5
jeep
bus
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/tail?sort=votes&pageSize=15>tail Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/tail?sort=votes&pageSize=15>tail Q&A on stackoverflow</a><li><a href=https://en.wikipedia.org/wiki/Tail_(Unix)#File_monitoring>wikipedia: File monitoring with tail -f and -F options</a><li><a href=https://unix.stackexchange.com/q/18760/109046>unix.stackexchange: How does the tail -f option work?</a><li><a href=https://mywiki.wooledge.org/BashFAQ/009>How to deal with output buffering?</a></ul><h2 id=head><a class=header href=#head>head</a></h2><p>By default, <code>head</code> displays the first 10 lines of input file(s). If there are less than 10 lines in the input, only those lines will be displayed. You can use the <code>-n</code> option to change the number of lines. By using <code>head -n -N</code>, you can get all the input lines except the last <code>N</code> lines.<pre><code class=language-bash># first three lines
$ head -n3 sample.txt
 1) Hello World
 2) 
 3) Hi there

# except the last 11 lines
$ head -n -11 sample.txt
 1) Hello World
 2) 
 3) Hi there
 4) How are you
</code></pre><p>You can select a range of lines by combining both <code>head</code> and <code>tail</code> commands.<pre><code class=language-bash># 9th to 11th lines
# same as: head -n11 sample.txt | tail -n3
$ tail -n +9 sample.txt | head -n3
 9) banana
10) papaya
11) mango
</code></pre><p>If you pass multiple input files, each file will be processed separately. By default, the output is nicely formatted with filename headers and empty line separators which you can override with the <code>-q</code> (quiet) option.<pre><code class=language-bash>$ printf '1\n2\n' | head -n1 greeting.txt -
==> greeting.txt <==
Hi there

==> standard input <==
1
</code></pre><p>The <code>-c</code> option works similar to the <code>-n</code> option, but with bytes instead of lines:<pre><code class=language-bash># first three characters
$ printf 'apple pie' | head -c3
app

# excluding last four characters
$ printf 'car\njeep\nbus\n' | head -c -4
car
jeep
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/head?sort=votes&pageSize=15>head Q&A on unix stackexchange</a></ul><h2 id=grep><a class=header href=#grep>grep</a></h2><p>Quoting from <a href=https://en.wikipedia.org/wiki/Grep>wikipedia</a>:<blockquote><p><strong><code>grep</code></strong> is a command-line utility for searching plain-text data sets for lines that match a regular expression. Its name comes from the <code>ed</code> command <code>g/re/p</code> (<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint), which has the same effect.</blockquote><p>The <code>grep</code> command has lots and lots of features, so much so that I wrote <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>a book</a> about it. The most common usage is filtering lines from the input using a regular expression (regexp).<p><strong>Options</strong><ul><li><code>--color=auto</code> highlight the matched pattern, filenames, line numbers, etc using colors<li><code>-i</code> ignore case while matching<li><code>-v</code> print non-matching lines<li><code>-n</code> prefix line numbers for matching lines<li><code>-c</code> display only the count of number of matching lines<li><code>-l</code> print only the filenames matching the given expression<li><code>-L</code> print filenames NOT matching the pattern<li><code>-w</code> match pattern only as whole words<li><code>-x</code> match pattern only as whole lines<li><code>-F</code> interpret pattern as a fixed string (i.e. not a regular expression)<li><code>-o</code> print only matching parts<li><code>-A N</code> print matching line and <code>N</code> number of lines after the matched line<li><code>-B N</code> print matching line and <code>N</code> number of lines before the matched line<li><code>-C N</code> print matching line and <code>N</code> number of lines before and after the matched line<li><code>-m N</code> print a maximum of <code>N</code> matching lines<li><code>-q</code> no standard output, quit immediately if match found, useful in scripts<li><code>-s</code> suppress error messages, useful in scripts<li><code>-r</code> recursively search all files in the specified input folders (by default searches current directory)<li><code>-R</code> like <code>-r</code>, but follows symbolic links as well<li><code>-h</code> do not prefix filename for matching lines (default behavior for single input file)<li><code>-H</code> prefix filename for matching lines (default behavior for multiple input files)</ul><p><strong>Examples</strong><p>All of the following examples would be suited for <code>-F</code> option as these do not use regular expressions. <code>grep</code> is smart enough to automatically apply <code>-F</code> for faster results in such cases.<pre><code class=language-bash># lines containing 'an'
$ printf 'apple\nbanana\nmango' | grep 'an'
banana
mango

# case insensitive matching
$ printf 'Cat\ncut\ncOnCaT\n' | grep -i 'cat'
Cat
cOnCaT

# match only whole words
$ printf 'par value\nheir apparent\n' | grep -w 'par'
par value

# count empty lines
$ grep -cx '' programming_quotes.txt
3

# matching line and two lines after
$ grep -A2 'blue' context.txt
blue
    toy
    flower
</code></pre><p><strong>Regular Expressions</strong><p>By default, <code>grep</code> treats the search pattern as Basic Regular Expression (BRE)<ul><li><code>-G</code> option can be used to specify explicitly that BRE is needed<li><code>-E</code> option will enable Extended Regular Expression (ERE) <ul><li>in <code>GNU grep</code>, BRE and ERE only differ in how metacharacters are specified, no difference in features</ul><li><code>-F</code> option will cause the search patterns to be treated literally<li><code>-P</code> if available, this option will enable Perl Compatible Regular Expression (PCRE)</ul><p>The following reference is for <strong>Extended Regular Expressions</strong>.<p><strong>Anchors</strong><ul><li><code>^</code> restricts the match to the start of the string<li><code>$</code> restricts the match to the end of the string<li><code>\<</code> restricts the match to the start of word<li><code>\></code> restricts the match to the end of word<li><code>\b</code> restricts the match to the start/end of words<li><code>\B</code> matches wherever <code>\b</code> doesn't match</ul><p><strong>Dot metacharacter and Quantifiers</strong><ul><li><code>.</code> match any character, including the newline character<li><code>?</code> match <code>0</code> or <code>1</code> times<li><code>*</code> match <code>0</code> or more times<li><code>+</code> match <code>1</code> or more times<li><code>{m,n}</code> match <code>m</code> to <code>n</code> times<li><code>{m,}</code> match at least <code>m</code> times<li><code>{,n}</code> match up to <code>n</code> times (including <code>0</code> times)<li><code>{n}</code> match exactly <code>n</code> times</ul><p><strong>Character classes</strong><ul><li><code>[set123]</code> match any of these characters once<li><code>[^set123]</code> match except any of these characters once<li><code>[3-7AM-X]</code> range of characters from <code>3</code> to <code>7</code>, <code>A</code>, another range from <code>M</code> to <code>X</code><li><code>\w</code> similar to <code>[a-zA-Z0-9_]</code> for matching word characters<li><code>\s</code> similar to <code>[ \t\n\r\f\v]</code> for matching whitespace characters<li><code>\W</code> match non-word characters<li><code>\S</code> match non-whitespace characters<li><code>[[:digit:]]</code> similar to <code>[0-9]</code><li><code>[[:alnum:]_]</code> similar to <code>\w</code> <ul><li>see <a href=https://www.gnu.org/software/grep/manual/grep.html#Character-Classes-and-Bracket-Expressions>grep manual</a> for full list</ul></ul><p><strong>Alternation and Grouping</strong><ul><li><code>pat1|pat2|pat3</code> match <code>pat1</code> or <code>pat2</code> or <code>pat3</code><li><code>()</code> group patterns, <code>a(b|c)d</code> is same as <code>abd|acd</code> <ul><li>also serves as a capture group</ul><li><code>\N</code> backreference, gives matched portion of <code>N</code>th capture group <ul><li><code>\1</code> backreference to the first capture group<li><code>\2</code> backreference to the second capture group and so on up to <code>\9</code></ul></ul><p>Quoting from the manual for BRE vs ERE differences:<blockquote><p>In basic regular expressions the meta-characters <code>?</code>, <code>+</code>, <code>{</code>, <code>|</code>, <code>(</code>, and <code>)</code> lose their special meaning; instead use the backslashed versions <code>\?</code>, <code>\+</code>, <code>\{</code>, <code>\|</code>, <code>\(</code>, and <code>\)</code>.</blockquote><p><strong>Examples</strong><pre><code class=language-bash># lines ending with 'ar'
$ printf 'spared no one\npar\nspar\ndare' | grep 'ar$'
par
spar

# extract 'part' or 'parrot' or 'parent' case insensitively
$ echo 'par part PARROT parent' | grep -ioE 'par(en|ro)?t'
part
PARROT
parent

# extract quoted text
$ echo 'I like "mango" and "guava"' | grep -oE '"[^"]+"'
"mango"
"guava"

# 8 character lines having same 3 lowercase letters at start and end
$ grep -xE '([a-z]{3})..\1' words.txt
mesdames
respires
restores
testates
</code></pre><p>The <code>-f</code> and <code>-x</code> options can be combined to get common lines between two files or the difference when <code>-v</code> is used as well. Add <code>-F</code> if you want to match the strings literally instead of regexp.<pre><code class=language-bash>$ printf 'teal\nlight blue\nbrown\nyellow\n' > colors_1
$ printf 'blue\nblack\ndark green\nyellow\n' > colors_2

# common lines between two files
$ grep -Fxf colors_1 colors_2
yellow

# lines present in colors_2 but not in colors_1
$ grep -Fvxf colors_1 colors_2
blue
black
dark green

# lines present in colors_1 but not in colors_2
$ grep -Fvxf colors_2 colors_1
teal
light blue
brown
</code></pre><p><strong>Perl Compatible Regular Expression</strong><p>PCRE has lot more features compared to BRE/ERE. Here are some examples:<pre><code class=language-bash># numbers >= 100, uses possessive quantifiers
$ echo '0501 035 154 12 26 98234' | grep -oP '0*+\d{3,}'
0501
154
98234

# extract digits only if preceded by =
$ echo '100 foo=42, bar=314' | grep -oP '=\K\d+'
42
314

# all digits and optional hyphen combo from the start of string
$ echo '123-87-593 42 foo' | grep -oP '\G\d+-?'
123-
87-
593

# all whole words except 'bat' and 'map'
$ echo 'car bat cod map combat' | grep -oP '\b(bat|map)\b(*SKIP)(*F)|\w+'
car
cod
combat
</code></pre><p><strong>Further Reading</strong><ul><li>My ebook <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>GNU GREP and RIPGREP</a> <ul><li>See also my blog post <a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>GNU BRE/ERE cheatsheet</a></ul><li><a href=https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html>Why GNU grep is fast</a><li><a href=https://stackoverflow.com/questions/tagged/grep?sort=votes&pageSize=15>grep Q&A on stackoverflow</a><li><a href=https://unix.stackexchange.com/questions/tagged/grep?sort=votes&pageSize=15>grep Q&A on unix stackexchange</a><li><a href=https://unix.stackexchange.com/q/131535/109046>unix.stackexchange: grep -r vs find+grep</a></ul><h2 id=find><a class=header href=#find>find</a></h2><p>The <code>find</code> command has comprehensive features to narrow down files and directories based on name, size, date and so on. And more importantly, <code>find</code> helps you to perform actions on such filtered files.<p><strong>Examples</strong><p>Filtering based on filename:<p>You have to construct a pattern that covers the entire filename, be it glob (<code>-name</code> and <code>-iname</code>) or regexp (<code>-regex</code>). The path(s) to search should be specified before any options like <code>-type</code>, <code>-name</code>, etc.<ul><li><code>find</code> by default, you'll get every entry (including hidden ones) in the current directory and sub-directories<li><code>find . -name '*log'</code> only files whose name ends with <code>log</code> in the current directory and sub-directories <ul><li>the argument to <code>-name</code> is treated as a <strong>glob</strong> (i.e. wildcards, not regex)<li>specifying <code>.</code> as the search path is optional</ul><li><code>find ~/reports /etc/ -name '*.txt'</code> filenames ending with <code>.txt</code> from the paths <code>~/reports</code> and <code>/etc/</code><li><code>find -iname 'power.log'</code> files named <code>power.log</code> (ignoring case) in the current directory and sub-directories<li><code>find -not -name '*log'</code> all files whose name does NOT end with <code>log</code><li><code>find -regextype egrep -regex '.*/\w+'</code> filenames containing only word characters <code>[a-zA-Z0-9_]</code> <ul><li><code>-regextype egrep</code> sets ERE (Extended Regular Expression) as the regexp flavor (default is <code>emacs</code> flavor)<li><code>.*/</code> is needed to match till the last <code>/</code> character in the file path</ul></ul><p>Filtering based on file type:<ul><li><code>find ~/proj -type f</code> all regular files<li><code>find ~/proj -type d</code> all directories<li><code>find ~/proj -type f -name '.*'</code> only hidden files</ul><p>Filtering based on depth:<p>The path being searched is considered as depth <code>0</code>, files in sub-directory are at depth <code>1</code>, files in sub-directory of a sub-directory are at depth <code>2</code> and so on.<ul><li><code>find -maxdepth 1 -type f</code> all regular files (including hidden ones) from current directory, but not sub-directories<li><code>find -maxdepth 1 -type f -name '[^.]*'</code> all regular files (but not hidden ones) from current directory, but not sub-directories <ul><li><code>-not -name '.*'</code> can be also used</ul><li><code>find -mindepth 1 -maxdepth 1 -type d</code> all directories (including hidden ones) in current directory, but not sub-directories <ul><li><code>-mindepth 1</code> is used to exclude the path being searched, which is considered as depth <code>0</code></ul></ul><p>Filtering based on file properties:<ul><li><code>find -mtime -2</code> files that were modified within the last two days <ul><li>Note that day here means 24 hours</ul><li><code>find -mtime +7</code> files that were modified more than seven days back<li><code>find -daystart -type f -mtime -1</code> files that were modified from beginning of day (not past 24 hours)<li><code>find -size +10k</code> files with size greater than 10 kilobytes<li><code>find -size -1M</code> files with size less than 1 megabytes<li><code>find -size 2G</code> files of size 2 gigabytes</ul><p>Passing filtered files as arguments to other commands:<ul><li><code>find report -name '*log*' -exec rm {} \;</code> delete all files containing <code>log</code> anywhere in the name <ul><li>here <code>rm</code> command is called for every file matching the given condition<li>since <code>;</code> is a special shell character, it needs to be escaped using <code>\</code></ul><li><code>find report -name '*log*' -delete</code> builtin option to delete files matching the given condition<li><code>find -name '*.txt' -exec wc {} +</code> files ending with <code>.txt</code> are all passed as arguments to the <code>wc</code> command <ul><li>no need to use escape the <code>+</code> character in this case<li><strong>note</strong> that the number of invocations of the command specified is not necessarily once if the number of files found are too large</ul><li><code>find -name '*.log' -exec mv {} ../log/ \;</code> move files ending with <code>.log</code> to the <code>log</code> directory present in one hierarchy above <ul><li><code>mv</code> is executed once per each filtered file</ul><li><code>find -name '*.log' -exec mv -t ../log/ {} +</code> the <code>-t</code> option allows to specify target directory, so you can use <code>+</code> instead of having to call <code>mv</code> once for each file found <ul><li>similarly, you can use <code>-t</code> for the <code>cp</code> command</ul></ul><p><strong>Further Reading</strong><ul><li><a href=https://mywiki.wooledge.org/UsingFind>mywiki.wooledge: using find</a><li><a href=https://unix.stackexchange.com/questions/tagged/find?sort=votes&pageSize=15>find Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/find?sort=votes&pageSize=15>find Q&A on stackoverflow</a><li><a href=https://unix.stackexchange.com/q/282762/109046>unix.stackexchange: find and tar example</a><li><a href=https://unix.stackexchange.com/q/321697/109046>unix.stackexchange: Why is looping over find's output bad practice?</a></ul><h2 id=locate><a class=header href=#locate>locate</a></h2><p><code>locate</code> is a faster alternative to the <code>find</code> command for searching files by name. It is based on a database, which gets updated by a <code>cron</code> job. So, newer files may be not present in results unless you update the database. Use this command if it is available in your distro and you remember some part of filename. Very useful if you have to search the entire filesystem in which case <code>find</code> command will take a very long time compared to <code>locate</code>.<p><strong>Examples</strong><ul><li><code>locate 'power'</code> print path of filenames containing <code>power</code> in the whole filesystem <ul><li>implicitly, <code>locate</code> would change the string to <code>*power*</code> as no globbing characters are present in the string specified</ul><li><code>locate -b '\power.log'</code> print path matching the string <code>power.log</code> exactly at the end of the path <ul><li><code>/home/learnbyexample/power.log</code> matches<li><code>/home/learnbyexample/lowpower.log'</code> will not match since there are other characters at the start of the filename<li>use of <code>\</code> prevents the search string from implicitly being replaced by <code>*power.log*</code></ul><li><code>locate -b '\proj_adder'</code> the <code>-b</code> option is also handy to print only the matching directory name, otherwise every file under that folder would also be displayed</ul><blockquote><p><img src=./images/info.svg alt=info> See also <a href=https://unix.stackexchange.com/q/60205/109046>unix.stackexchange: pros and cons of find and locate</a>.</blockquote><h2 id=wc><a class=header href=#wc>wc</a></h2><p>The <code>wc</code> command is useful to count the number of lines, words and characters for the given input(s).<p><strong>Examples</strong><pre><code class=language-bash>$ cat greeting.txt
Hi there
Have a nice day

# by default, gives newline/word/byte count (in that order)
$ wc greeting.txt
 2  6 25 greeting.txt

# get only the specified counts
$ wc -l greeting.txt
2 greeting.txt
$ wc -w greeting.txt
6 greeting.txt
$ wc -c greeting.txt
25 greeting.txt
$ wc -wc greeting.txt
 6 25 greeting.txt

# filename won't be printed for stdin data
$ wc -l &LTgreeting.txt
2
</code></pre><p>Word count is based on whitespace separation. You'll have to pre-process the input if you do not want certain non-whitespace characters to influence the results. <code>tr</code> is helpful to remove the given set of characters, or its complement (this command will be discussed later).<pre><code class=language-bash>$ echo 'apple ; banana ; cherry' | wc -w
5

# remove characters other than alphabets and whitespace
$ echo 'apple ; banana ; cherry' | tr -cd 'a-zA-Z[:space:]'
apple  banana  cherry
$ echo 'apple ; banana ; cherry' | tr -cd 'a-zA-Z[:space:]' | wc -w
3
</code></pre><p>If you pass multiple files to the <code>wc</code> command, the count values will be displayed separately for each file. You'll also get a summary at the end, which sums the respective count of all the input files.<pre><code class=language-bash>$ wc greeting.txt nums.txt purchases.txt
 2  6 25 greeting.txt
 3  3 13 nums.txt
 8  9 57 purchases.txt
13 18 95 total
</code></pre><p>You can use the <code>-L</code> to report the length of the longest line in the input (excluding the newline character of a line). Note that <code>-L</code> won't count non-printable characters and tabs are converted to equivalent spaces. Multibyte characters will each be counted as <code>1</code> (depending on the locale, they might become non-printable too).<pre><code class=language-bash>$ echo 'apple' | wc -L
5
$ wc -L &LTsample.txt
26
</code></pre><p>Use <code>-m</code> option instead of <code>-c</code> if the input has multibyte characters.<pre><code class=language-bash>$ printf 'αλεπού' | wc -c
12

$ printf 'αλεπού' | wc -m
6
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/wc?sort=votes&pageSize=15>wc Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/wc?sort=votes&pageSize=15>wc Q&A on stackoverflow</a></ul><h2 id=du><a class=header href=#du>du</a></h2><p>The <code>du</code> command helps you estimate the size of files and directories.<p><strong>Examples</strong><p>By default, size is given in size in terms of 1024 bytes. All directories and sub-directories are recursively reported, but files are ignored. You can use the <code>-a</code> option if files should also be reported. <code>du</code> is one of the commands that require an explicit option (<code>-L</code> in this case) if you want symbolic links to be dereferenced.<pre><code class=language-bash>$ du
17920   ./projs/full_addr
14316   ./projs/half_addr
32952   ./projs
33880   .
</code></pre><p>Use <code>-s</code> option to show total directory size without descending into sub-directories. Add <code>-c</code> option to also show total size at the end.<pre><code class=language-bash>$ du -s projs words.txt
32952   projs
924     words.txt
</code></pre><p>Here are some examples to show different size formatting options available:<pre><code class=language-bash># number of bytes
$ du -b words.txt
938848  words.txt

# kilobytes (1024 bytes)
$ du -sk projs
32952   projs

# megabytes (1024 kilobytes)
$ du -sm projs
33      projs

# -h is for human readable
# use --si for powers of 1000 instead of 1024
$ du -h words.txt
924K    words.txt
</code></pre><p>If you use <code>du -h</code>, you can pipe the output to <code>sort -h</code> for sorting based on human readable size:<pre><code class=language-bash>$ du -sh projs/* words.txt | sort -h
712K    projs/report.log
924K    words.txt
14M     projs/half_addr
18M     projs/full_addr
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/disk-usage?sort=votes&pageSize=15>du Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/du?sort=votes&pageSize=15>du Q&A on stackoverflow</a></ul><h2 id=df><a class=header href=#df>df</a></h2><p>The <code>df</code> command gives you the space usage of file systems.<p><strong>Examples</strong><p><code>df</code> without path arguments will give information about all the currently mounted file systems. You can specify <code>.</code> to get information only for the current filesystem:<pre><code class=language-bash>$ df .
Filesystem     1K-blocks     Used Available Use% Mounted on
/dev/sda1       98298500 58563816  34734748  63% /
</code></pre><p>Use <code>-h</code> option for human readable sizes. The <code>-B</code> option allows you to scale sizes by the specified amount. Use <code>--si</code> for size in powers of <code>1000</code> instead of <code>1024</code>.<pre><code class=language-bash>$ df -h .
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        94G   56G   34G  63% /
</code></pre><p>Use <code>--output</code> to report only specific fields of interest:<pre><code class=language-bash>$ df -h --output=size,used,file / /media/learnbyexample/projs
 Size  Used File
  94G   56G /
  92G   35G /media/learnbyexample/projs

$ df -h --output=pcent .
Use%
 63%

# 'awk' here excludes first line and matches lines with first field >= 40
$ df -h --output=pcent,fstype | awk 'NR>1 && $1>=40'
 63% ext3
 40% ext4
 51% ext4
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://stackoverflow.com/questions/tagged/df?sort=votes&pageSize=15>df Q&A on stackoverflow</a></ul><h2 id=touch><a class=header href=#touch>touch</a></h2><p>As mentioned earlier, the <code>touch</code> command helps you change the timestamps of files. You can do so based on current timestamp, passing an argument, copying the value from another file and so on.<p><strong>Examples</strong><p>By default, <code>touch</code> updates both access and modification timestamp to the current time. You can use <code>-a</code> to change only access timestamp and <code>-m</code> to change only modification timestamp. The <code>stat</code> command is also used here for illustration purposes:<pre><code class=language-bash># last access and modification time
$ stat -c $'%x\n%y' fruits.txt
2017-07-19 17:06:01.523308599 +0530
2017-07-13 13:54:03.576055933 +0530

$ touch fruits.txt 
$ stat -c $'%x\n%y' fruits.txt
2017-07-21 10:11:44.241921229 +0530
2017-07-21 10:11:44.241921229 +0530
</code></pre><p>You can use the <code>-r</code> option to copy timestamp information from one file to another. The <code>-d</code> and <code>-t</code> options will allow you to specify timestamps directly as part of the command.<pre><code class=language-bash># copy timestamp from 'power.log' to 'report.log'
# add -a or -m as needed
$ touch -r power.log report.log
</code></pre><p>As seen earlier, <code>touch</code> creates a new file if the given argument doesn't exist yet. You can use the <code>-c</code> option to prevent this behavior.<pre><code class=language-bash>$ ls report.txt
ls: cannot access 'report.txt': No such file or directory
$ touch report.txt
$ ls report.txt
report.txt

$ touch -c xyz.txt
$ ls xyz.txt
ls: cannot access 'xyz.txt': No such file or directory
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/questions/tagged/touch?sort=votes&pageSize=15>touch Q&A on unix stackexchange</a></ul><h2 id=file><a class=header href=#file>file</a></h2><p>The <code>file</code> command helps you identify text encoding (ASCII, UTF-8, etc), whether the file is executable and so on.<p><strong>Examples</strong><p>Here are some examples of how the <code>file</code> command behaves for different types:<pre><code class=language-bash>$ file sample.txt 
sample.txt: ASCII text

$ printf 'αλεπού\n' | file -
/dev/stdin: UTF-8 Unicode text

$ file ch
ch:  Bourne-Again shell script, ASCII text executable

$ printf 'hi\r\n' | file -
/dev/stdin: ASCII text, with CRLF line terminators

$ file sunset.jpg moon.png
sunset.jpg: JPEG image data
moon.png: PNG image data, 32 x 32, 8-bit/color RGBA, non-interlaced
</code></pre><p>You can use the <code>-b</code> option to avoid filenames in the output:<pre><code class=language-bash>$ file -b sample.txt 
ASCII text
</code></pre><p>Here is an example of finding particular type of files, say <code>image</code> files.<pre><code class=language-bash># '$0' contains the name of files passed from 'find' to 'bash'
$ find -type f -exec bash -c '
       (file -b "$0" | grep -wq "image data") && echo "$0"' {} \;
./sunset.jpg
./moon.png

# if filenames do not contain ':' or newline characters
$ find -type f -exec file {} + | awk -F: '/\&LTimage data\>/{print $1}'
./sunset.jpg
./moon.png
</code></pre><blockquote><p><img src=./images/info.svg alt=info> See also <code>identify</code> command which "describes the format and characteristics of one or more image files".</blockquote><h2 id=basename><a class=header href=#basename>basename</a></h2><p>By default, the <code>basename</code> command will remove the leading directory component from the given path argument. Any trailing slashes will be removed before determining the portion to be extracted.<pre><code class=language-bash>$ basename /home/learnbyexample/example_files/scores.csv
scores.csv

# quote the arguments when needed
$ basename 'path with spaces/report.log'
report.log
</code></pre><p>You can use the <code>-s</code> option to remove a suffix from the filename. Usually used to remove the file extension.<pre><code class=language-bash>$ basename -s'.csv' /home/learnbyexample/example_files/scores.csv
scores

$ basename -s'.txt' purchases.txt.txt
purchases.txt
</code></pre><p>The <code>basename</code> command requires <code>-a</code> or <code>-s</code> (which implies <code>-a</code>) to work with multiple arguments.<pre><code class=language-bash>$ basename -a /backups/jan_2021.tar.gz /home/learnbyexample/report.log
jan_2021.tar.gz
report.log

# -a is implied when -s is used
$ basename -s'.txt' logs/purchases.txt logs/report.txt
purchases
report
</code></pre><h2 id=dirname><a class=header href=#dirname>dirname</a></h2><p>By default, the <code>dirname</code> command removes the trailing path component (after removing any trailing slashes).<pre><code class=language-bash>$ dirname /home/learnbyexample/example_files/scores.csv
/home/learnbyexample/example_files

# one or more trailing slashes will not affect the output
$ dirname /home/learnbyexample/example_files/
/home/learnbyexample

# unlike basename, multiple arguments are accepted by default
$ dirname /home/learnbyexample/example_files/scores.csv ../report/backups/
/home/learnbyexample/example_files
../report
</code></pre><p>You can use shell features like command substitution to combine the effects of <code>basename</code> and <code>dirname</code> commands.<pre><code class=language-bash># extract the second last path component
$ basename $(dirname /home/learnbyexample/example_files/scores.csv)
example_files
</code></pre><h2 id=chmod><a class=header href=#chmod>chmod</a></h2><p>This section will show how you can use the <code>chmod</code> command to change file permissions. Consider this <code>ls</code> long listing example:<pre><code class=language-bash>$ ls -l sample.txt 
-rw-rw-r-- 1 learnbyexample learnbyexample 111 May 25 14:47 sample.txt
</code></pre><p>In the above output of <code>ls -l</code> command, the 10 characters displayed in the first column are related to file type and permissions. First character indicates the <strong>file type</strong>. The most common ones are shown below. See <code>-l</code> option in <code>info ls</code> for complete list.<ul><li><code>-</code> regular file<li><code>d</code> directory<li><code>l</code> symbolic link</ul><p>The other nine characters represent three sets of <strong>file permissions</strong> for <code>user</code>, <code>group</code> and <code>others</code>, in that order.<ul><li><code>user</code> file properties for owner of the file (<code>u</code>)<li><code>group</code> file properties for the group the file belongs to (<code>g</code>)<li><code>others</code> file properties for everyone else (<code>o</code>)</ul><p>Only <code>rwx</code> file properties will be discussed in this section. For other types of properties, <a href=https://www.mkssoftware.com/docs/man1/ls.1.asp#Long_Output_Format>refer to this documentation</a>.<p><strong>Permission reference table for files:</strong><table><thead><tr><th>Character<th>Meaning<th>Value<tbody><tr><td><code>r</code><td>read<td><code>4</code><tr><td><code>w</code><td>write<td><code>2</code><tr><td><code>x</code><td>execute<td><code>1</code><tr><td><code>-</code><td>no permission<td><code>0</code></table><blockquote><p><img src=./images/info.svg alt=info> Note that the permissions are not straightforward to understand for directories. If a directory only has the <code>x</code> permission, you can <code>cd</code> into it but you cannot read the contents (using <code>ls</code> for example). If a directory only has the <code>r</code> permission, you cannot <code>cd</code> into it, but you'll be able to read the contents (along with "cannot access" error). For this reason, <code>rx</code> permissions are almost always enabled/disabled together. The <code>w</code> permission allows you to add or remove contents, provided <code>x</code> is active.</blockquote><p><strong>Changing permissions for all three categories</strong><p>You can provide numbers for <code>u g o</code> (in that order) to change <code>rwx</code> permissions.<pre><code class=language-bash># r(4) + w(2) + 0 = 6
# r(4) + 0 + 0 = 4
$ chmod 664 sample.txt 
$ ls -lF sample.txt 
-rw-rw-r-- 1 learnbyexample learnbyexample 148 May 29 11:00 sample.txt

# r(4) + w(2) + x(1) = 7
# r(4) + 0 + x(1) = 5
$ chmod 755 hello_world.pl 
$ ls -lF hello_world.pl 
-rwxr-xr-x 1 learnbyexample learnbyexample 40 May 28 13:25 hello_world.pl*

$ chmod 775 report/
$ ls -ld report/
drwxrwxr-x 2 learnbyexample learnbyexample 4096 May 29 14:01 report/
</code></pre><p><strong>Changing permissions for specific categories</strong><p>The permissions that are affected by <code>+-/rwx</code> depends on <code>umask</code> value as well. It is usually <code>002</code> which means:<ul><li><code>+r -r +x -x</code> without <code>u g o</code> qualifier affects all the three categories<li><code>+w -w</code> without <code>u g o</code> qualifier affects only <code>user</code> and <code>group</code> categories</ul><pre><code class=language-bash># add execute permission for all three categories
$ chmod +x report.sh

# add write permission only for 'user' and 'group'
$ chmod +w ip.txt

# remove read and execute permissions for all three categories
$ chmod -rx source_files

# remove read and write permission only for 'others'
$ chmod o-rw sample.txt

# remove execute permission for 'group' and 'others'
$ chmod go-x hello_world.pl

# add execute permission for 'group' and 'others'
$ chmod go+x hello_world.pl
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://danielmiessler.com/study/unixlinux_permissions/>Linux Permissions Primer</a><li><a href=https://unix.stackexchange.com/questions/tagged/chmod?sort=votes&pageSize=15>chmod Q&A on unix stackexchange</a><li><a href=https://stackoverflow.com/questions/tagged/chmod?sort=votes&pageSize=15>chmod Q&A on stackoverflow</a><li><a href=https://unix.stackexchange.com/q/429421/109046>unix.stackexchange: why chmod +w filename not giving write permission to other</a></ul></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=managing-files-directories.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=text-processing.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=managing-files-directories.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=text-processing.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>